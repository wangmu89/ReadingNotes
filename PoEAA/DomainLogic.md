[toc]

### 1. 组织领域逻辑（Organizing Domain Logic）

```markdown
**领域逻辑模式的示例：`收入确认问题`**
假定某公司出售三种产品：文字处理软件、数据库和电子表格软件。
当售出一个文字处理软件时，所有收入可以立即入账；
当售出一个电子表格软件时，当天入账1/3，60天后入账1/3，剩下的1/3在90天时入账；
当售出一个数据库软件时，当天入账1/3，30天后入账1/3，剩下的1/3在60天时入账。
![aaa](./_Resources/应用中层次的演化.png)
```

组织领域逻辑的三种主要的模式：**事务脚本（Transaction Script）**、**领域模型（Domain Model）**和**表模块（Table Module）**。

#### 1.1 事务脚本（Transaction Script）

> 使用过程（procedures）来组织业务逻辑，每个过程处理来自表现层的单个请求。

业务应用可以被看作是一系列事务，一个事务可能将某种信息看作是以特定方式组织的，然后另一个事务则会改变它。客户系统与服务器系统之间的每次交互包含一定数量的逻辑，`事务脚本（Transaction Script）`将所有这些逻辑组织成单个过程。例如，一个零售系统可能会有将商品放入购物车、结账、查看交货状态以及其他一些`事务脚本`。

##### 运行机制

使用`事务脚本`时，领域逻辑主要通过系统所执行的事务来组织。例如：”预定酒店房间“这样的需求，在它的过程中会发现用于查找空房间、计算价格和更新数据库的逻辑。

`事务脚本`可能位于服务器页面、CGI脚本或分布式会话对象中，最好的方法是**尽可能分离事务脚本**，将它们置于与其他处理表现层和数据源层的类相独立的类中。为了更容易修改代码和测试`事务脚本`，*绝不要让事务脚本调用任何表现层逻辑*。

将`事务脚本`组织成类的两种方法：

- 将数个`事务脚本`放在一个类中，每个类**围绕一个主题**将相关的`事务脚本`组织在一起。*（最常用的方法）*
- 每一个`事务脚本`对应一个类，使用命令（Command, [Gang of Four]）模式定义一个所有命令的父类，在父类中声明`事务脚本`逻辑适合的执行方法。（*优点在于：允许你运行时以对象的方式操控脚本类的实例。*）

##### 使用时机

`事务脚本`有如下几个优点：

- 它是一个大多数开发者都能理解的简单过程模型。
- 它能够与一个使用`行数据入口（Row Data Gateway）`或`表数据入口（Table Data Gateway）`的简单数据源层很好的协作。
- 设定事务边界的方法显而易见：一个事务始于其脚本的打开，终于其脚本的关闭。

但是当业务逻辑越来越复杂时，这一模式就会难以保持良好的设计。它特有的问题是*事务之间的冗余代码*，事务需要做相似的动作时，会导致某些相同的代码，通过提取这些代码为公共子例程可以部分消除这种情况，但更复杂的业务领域需要建立`领域模型（Domain Model）`。

##### 示例：”收入确认问题“

